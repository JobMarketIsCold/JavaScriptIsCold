<h2>JS의 constructor 구분법</h2>
<h3>JS에 ES6 문법이 도입된 이후 개발을 시작하신 분들이라면 대부분 함수 표현식이나 함수 선언을 할 때 function()보다는 화살표 함수(=>)를 사용하셨을 겁니다.

훨씬 간결하고 단순하니까요.

그런데,function()은 아니지만 화살표 함수를 new 연산자를 활용해서 생성자 함수로 호출하려고 하면 에러가 발생합니다. 둘 다 함수인데 왜 불가능할까요?</h3>

<h2></h2>
<h3>
이를 이해하기 위해서는 JS 엔진이 어떻게 constructor와 non-constructor를 구분하는 지 이해해야 합니다.</h3><br>

> constructor: 함수 선언문, 함수 표현식, 클래스<br>
> non-constructor: 메서드(ES6의 메서드 축약 표현만), 화살표 함수

자바스크립트 엔진은 함수 객체를 생성할 때 함수 정의 방식에 따라 함수를 위 두 가지로 구분합니다.
그런데, non-constructor를 구분할 때의 메서드는 우리가 생각하는 메서드보다 의미가 좁습니다.

보통 함수를 프로퍼티 값으로 사용하게 되면 일반적으로 이는 메서드로 통칭합니다. 그러나 ES(ECMAScript) 사양에서는 메서드를 ES6의 메서드 축약 표현만을 의미한다고 합니다. 즉, 함수가 어디에 할당되었는지에 따라 메서드인지 판단하지 않고, 함수 정의 방식에 따라 constructor인지, non-constructor인지를 구분합니다.

방법은 이와 같습니다.

```js
const 생성자함수가능 = function () {};

생성자함수가능(); // [[Call]]이 호출됨.
new 생성자함수가능(); // [Construct]가 호출됨.

const 생성자함수안됨 = () => {};

생성자함수안됨(); // [[Call]]이 호출됨.
new 생성자함수안됨(); // [[Construct]]가 없어 에러 발생
```

모든 함수 객체는 [[Call]]이 구현되어 있습니다. 그러나 new연산자와 함께 생성자 함수로서 생성 시에 호출되는 [[Construct]]는 constructor만 가지고 있습니다. 그래서 non-constructor인 함수 객체를 생성자 함수로 호출하게 된다면 에러가 발생합니다.

<h2></h2>

<h3>이러한 constructor 구분법은 JS에서 함수가 객체이기 때문에 가능한 것 같습니다. 다음에는 함수 객체의 내부를 하나하나 뜯어보며 이해해 봐야겠습니다.
