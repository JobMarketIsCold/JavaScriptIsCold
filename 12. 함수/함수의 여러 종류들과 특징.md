## 함수의 여러 종류들과 특징

### 자바스크립트에는 화살표 함수, 생성자 함수와 같은 다양한 형태의 함수가 존재합니다. 오늘은 여러 함수들의 특징과 사용처를 알아보려 합니다.

##

> 함수는 일련의 과정을 문(statement)으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.

모던 자바스크립트 deep dive에선 함수를 위와 같이 정의합니다.

함수의 유용함부터 시작해서 정의법까지 설명하기에는 좀 그러니 바로 본론으로 들어가 보겠습니다.

## 함수 정의 방식의 차이

자바스크립트는 네 가지의 함수 정의 방식을 가지고 있습니다. 이는 자바스크립트 엔진에 의해 평가되어 함수 객체가 됩니다.

- 함수 선언문

```js
function asdf(x, y) {
  return x + y;
} // 우리가 일반적으로 아는 평범한 함수 선언이 함수 선언문입니다.
```

- 함수 표현식

```js
const asdf = function (x, y) {
  return x + y;
}; // 변수에 함수를 할당하면 함수 표현식입니다.
```

- Function 생성자 함수

```js
const asdf = new Function('x', 'y', 'return x + y');
// new 키워드를 활용하여 새로운 함수 객체를 생성하면 생성자 함수입니다.
```

- 화살표 함수

```js
const asdf = (x, y) => x + y;
// 화살표(=>) 를 이용하여 함수를 만들었다면 화살표 함수입니다.
```

위 네 가지가 일반적인 함수 정의입니다.

이 중, 우리가 코딩할 때 간단하게 사용할 수 있어 자주 사용하는 화살표 함수는 function으로 선언하는 일반 함수를 선언할 때와는 조금 다른 점이 있습니다.

### 화살표 함수에는 this가 없다

먼저, 화살표 함수에는 **this가 없습니다.** 따라서 외부의 this를 그대로 사용하게 됩니다.

이런 현상이 일어나는 이유는, **자바스크립트 엔진이 변수를 찾을 때 좁은 범위에서부터 넓은 범위로 검색해 나가기 때문입니다.** 따라서 화살표 함수 내에서 this를 찾으려 했지만, this가 없으므로 함수 외부에서 this를 검색하게 되고, 이를 사용하게 되는 것입니다.

따라서, 이 점을 이해하게 되면 this를 사용해야 할 때 화살표 함수를 사용해서 외부의 this를 참조하는 불상사를 방지할 수 있습니다.

### 화살표 함수는 생성자 함수로 사용할 수 없다

함수도 객체이기 때문에, 빈 함수라도 자신이 정의하지 않은, 여러 변수들이 많습니다. 그러나, 일반 함수와는 다르게 화살표 함수의 console.log를 찍어 보면 **생성자를 의미하는 constructor가 존재하지 않습니다.** 따라서 화살표 함수는 생성자 함수로 사용할 수 없습니다.

이 정도가 화살표 함수와 일반 함수의 차이라고 볼 수 있습니다. 그러나 평소에 사용할 때도 의식해야 할 만큼 큰 차이는 아니라고 생각합니다.

##

## 함수 호이스팅

함수 또한 변수처럼 호이스팅이 발생합니다. 그러나 이는 함수 표현식이냐, 함수 선언문이냐에 따라 발생 여부가 다릅니다.

- 함수 선언문의 경우

```js
asdf(); // 함수 호출

function asdf() {
  console.log('hello!'); // 정상 작동
}
```

함수 선언문은 전체가 끌어올려지기 때문에 함수 호출을 선언문보다 앞에 놓아도 정상적으로 동작합니다.

- 함수 표현식의 경우

```js
asdf(); // error

const asdf = function () {
  console.log('hello'); //
};
```

그러나 함수 표현식에서는 에러가 발생합니다. 그 이유는 함수 표현식에서는 함수 호이스팅 대신 **변수 호이스팅**이 발생하기 때문입니다.

함수 표현식은 변수에 함수를 할당하는 형태입니다. 따라서 변수는 런타임 이전에 undefined로 초기화되기 때문에 변수 선언문 이전에 변수를 참조하면 undefined로 평가됩니다.

즉, 함수 표현식이냐 함수 선언문이냐에 따라 함수 호이스팅 여부가 다른 것은 **함수 생성 시점이 다르기 때문**으로 볼 수 있습니다.

##

## 여러 가지 함수의 형태

마지막으로 여러 함수의 형태에 대해 소개하고 끝내겠습니다.

- 즉시 실행 함수(IIFE - Immediately Invoked Function Expression)

```js
(function () {
  // 즉시 실행 함수의 형태
  const a = 3;
  const b = 2;
  return a + b;
})();
```

즉시 실행 함수는 함수 정의와 동시에 호출되며, 단 한 번만 호출되고 다시 호출할 수 없습니다.

즉시 실행 함수는 반드시 그룹 연산자()로 감싸야 합니다.

즉시 실행 함수는 자체적인 스코프를 생성하므로, 함수 내에서 정의된 변수들은 외부 스코프에 노출되지 않습니다. 이를 통해 변수 충돌을 방지하고 전역 스코프를 깨뜨리지 않을 수 있습니다.

- 재귀 함수(Recursive Function)

```js
function count(n) {
  for (let i = n; i >= 0; i--) console.log(i);
}
count(10);
```

팩토리얼 구현할 때 항상 나오는 재귀 함수는 자기 자신을 호출하는 함수를 말합니다.

재귀 함수는 자기 자신을 무한으로 호출하기 때문에, 탈출 조건을 만들어야 합니다. 그렇지 않으면 stack overflow가 발생합니다.

- 중첩 함수

```js
function out(){
    let i = 0;

    function in(){
        let x = 2;
        console.log(i + x); // 외부 함수의 변수 참조 가능(클로저)
    }
    in();
}
out();
```

함수 내부에 정의된 함수를 중첩 함수(내부 함수)라고 합니다. 그리고 중첩 함수를 포함하는 함수는 외부 함수라고 부릅니다. 중첩 함수는 외부 함수의 역할을 돕는 헬퍼 함수의 역할을 주로 합니다.

ES6 문법에 들어와서는 if문이나 for문 등 코드 블록에서도 정의할 수 있습니다. 그러나 이는 클로저를 형성하여 예상치 못한 동작이 발생 가능하므로 지양하는 것이 좋습니다.

- 콜백 함수

```js
function bye(n) {
  for (let i = 0; i < n; i++) console.log(i);
}
bye(5);
```

위 bye 함수는 console.log(i)에 강하게 의존하여 다른 일을 할 수 없습니다.

```js
function hello(name, callback) {
  console.log('Hello, ' + name + '!');
  callback();
}

function bye() {
  console.log('Goodbye!');
}

hello('hun', bye);
```
